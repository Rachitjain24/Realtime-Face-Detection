````markdown
# Real-Time Face Compression Flask App

A single-file Flask application (`real_time_face_compression_flask.py`) that:

1. Captures webcam frames  
2. Detects faces using OpenCV Haar cascades  
3. Compresses frames to JPEG and WebP at adjustable quality  
4. Computes PSNR & SSIM metrics per frame  
5. Streams video, face ROIs, and algorithm step previews  
6. Displays live charts of quality metrics and frame sizes

---

## File: `real_time_face_compression_flask.py`

### 1. Imports & Initialization

```python
from flask import Flask, Response, render_template_string, request, jsonify, url_for
import cv2, numpy as np, threading, time
from skimage.metrics import structural_similarity as compare_ssim

app    = Flask(__name__)
cap    = cv2.VideoCapture(0)
cascade= cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
````

* **Flask** for the web server
* **OpenCV** for video capture & face detection
* **NumPy** for array math
* **scikit-image** for SSIM
* A background thread continuously grabs frames and computes metrics

---

### 2. Global State

```python
quality = 50                  # JPEG/WebP compression quality (10–100)
jpeg_psnr_vals, webp_psnr_vals = [], []
jpeg_ssim_vals, webp_ssim_vals = [], []
jpeg_size_vals, webp_size_vals = [], []
times = []                    # Timestamps for charts
start_time = time.time()
last_face = None              # Stores latest detected face ROI
lock = threading.Lock()       # Mutex for shared data
```

---

### 3. HTML Templates

* **`LANDING_TEMPLATE`**: Explains PSNR/SSIM & algorithm steps, “Proceed to Demo” button
* **`DEMO_TEMPLATE`**:

  * Video feed
  * Face ROI feed
  * Algorithm step selector & preview
  * Compression quality slider
  * Chart.js graphs for PSNR, SSIM, size, ΔPSNR

Templates are rendered with `render_template_string()`.

---

### 4. Helper Functions

```python
def compute_psnr(a, b):
    mse = np.mean((a.astype(np.float64) - b.astype(np.float64))**2)
    return 100.0 if mse == 0 or not np.isfinite(mse) else 20 * np.log10(255.0/np.sqrt(mse))
```

* **`compute_psnr`**: returns PSNR in dB, handles zero-MSE case.

```python
def process_step(frame, step):
    # 5.1 capture; 5.2 face detection; 5.2g grayscale;
    # 5.3 decompress; 5.4 overlay metrics; 5.6 side-by-side
    ...
    return img
```

* **`process_step`**: generates a preview image for each algorithm step.

---

### 5. Background Metrics Thread

```python
def bg():
    while True:
        ret, frame = cap.read()
        # detect faces, update last_face
        # encode JPEG & WebP at current quality
        # compute PSNR & SSIM, sizes, timestamp
        time.sleep(0.1)
```

* Runs as a daemon thread alongside Flask
* Populates global lists for live-charting

---

### 6. Flask Routes

1. **`GET /`** → Landing page
2. **`GET /demo`** → Demo dashboard
3. **`GET /video_feed`**

   * Multipart JPEG stream of live video with face rectangles
4. **`GET /face_feed`**

   * Multipart JPEG stream of the latest face ROI
5. **`POST /set_quality`**

   * JSON `{ "quality": <int> }`
   * Updates compression quality, clears metrics
6. **`GET /metrics`**

   * JSON with arrays: `times`, `jpeg_psnr`, `webp_psnr`, `jpeg_ssim`, `webp_ssim`, `jpeg_size`, `webp_size`
7. **`GET /step_image?step=<id>`**

   * Returns JPEG of `process_step(frame, step)` preview

---

### 7. Entry Point

```python
if __name__ == '__main__':
    threading.Thread(target=bg, daemon=True).start()
    app.run(host='0.0.0.0', port=5000, threaded=True)
```

* Starts the background metrics thread
* Launches Flask on port 5000

---

## How to Run

1. **Install dependencies**

   ```bash
   pip install flask opencv-python numpy scikit-image
   ```

2. **Execute**

   ```bash
   python real_time_face_compression_flask.py
   ```

3. **Browse**

   * Landing: `http://localhost:5000/`
   * Demo: click **Proceed to Demo**

---

## Key Configuration

* **Compression Quality**: slide between 10%–100%
* **Frame Interval**: metrics recalculated every 0.1 s
* **Face ROI Scale**: detection on quarter-resolution frames for speed

---

## Extending the Code

* Swap Haar cascades for DNN-based face detectors
* Add more compression formats (e.g. PNG, AVIF)
* Persist metrics to file or database
* Export live charts as CSV/JSON

---

*This README focuses on the code structure, endpoints, and operation of the single-file Flask app.*
